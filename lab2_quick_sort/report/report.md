# 《操作系统》课程实验报告 高级进程间通信 快速排序问题

> 姓名：陈彦旭
>
> 班级：无24

## 1 实验目的

1. 通过对进程间高级通信问题的编程实现，加深理解进程间高级通信的原理；
2. 对 Windows 或 Linux 涉及的几种高级进程间通信机制有更进一步的了解；
3. 熟悉 Windows 或 Linux 中定义的与高级进程间通信有关的函数。

## 2 问题描述

对于有 1,000,000 个乱序数据的数据文件执行快速排序。

## 3 实验步骤

（1）首先产生包含 1,000,000 个随机数（数据类型可选整型或者浮点型）的数据文件；

（2）每次数据分割后产生两个新的进程（或线程）处理分割后的数据，每个进程（线程）处理的数据小于 1000 以后不再分割（控制产生的进程在 20 个左右）；

（3）线程（或进程）之间的通信可以选择下述机制之一进行：管道（无名管道或命名管道），消息队列，共享内存。

（4）通过适当的函数调用创建上述 IPC 对象，通过调用适当的函数调用实现数据的读出与写入；

（5）需要考虑线程（或进程）间的同步；

（6）线程（或进程）运行结束，通过适当的系统调用结束线程（或进程）。

## 4 设计思路

> OS: Ubuntu 24.04.2 LTS x86_64.
>
> Language: C++.

选择“共享内存”机制实现，基于 Linux 中的 POSIX 机制，建立命名的共享内存，通过一个唯一的名称标识共享内存。

首先使用 python 脚本生成 1,000,000 个随机整数，保存为二进制文件 `dada/integers.bin` 。

主进程首先从二进制文件中读取数据，创建一片 `SharedData` 类型的共享内存数据，将数据加载到共享内存中。设置共享内存名称，这是后续子进程创建新的 `SharedMemory` 对象的重要依据。创建第一个共享内存 `SharedMemory` 对象。在构造函数中，主进程负责完成以下操作：

1. 通过系统调用 `shm_open` 创建一片共享内存区域。
2. 通过系统调用 `ftruncate` 设置共享内存的大小。
3. 通过系统调用 `mmap` 映射共享内存到进程的地址空间，获得可以指向共享内存的 `SharedData*` 指针。
4. 初始化这块共享内存的元数据，包括元素数量、数据是否有序标志、读写锁等。

每一次递归划分生成的子进程，接收“共享内存名称、共享内存大小、是否为创建者”三个参数，建立 `SharedMemory` 对象，在构造函数中，基本重复父进程的操作，但是不会进行改变共享内存大小、不会修改共享内存的元数据。

每次划分出的子进程分别处理左右两个子区间，各个子进程 “原地”修改共享内存中某一个区间内的数据，子进程又可重复父进程的操作继续递归划分。在快速排序算法中，由于不同的子进程负责排序不同的划分区域，因此不会出现数据竞争，理论上可以不需要读写锁。若对数据区域加锁，则同一时间只能有一个进程对数据进程排序，其他进程只能等待，无法实现进程的并发执行，影响排序的并发性能，当排序数据量很大时性能会降低。

一个关键点：pthread_mutex_t 确实来自线程库（POSIX Threads，即 pthread），但在代码中它被用于进程间通信。这是通过特殊配置实现的。

不同进程持有的是同一个共享内存，也就是最初父进程创建的共享内存，但是他们持有的共享内存的对象不同，因为需要区分当前进程是否为最初的父进程，只有最初的父进程才能创建共享内存、创建地址映射、在排序完成后取消映射并销毁共享内存。不同的进程持有不同的共享内存类 `SharedMemory` 对象，这些不同的对象通过类中成员 `SharedData *_shm_ptr` 这个指向同一片共享内存数据的指针，实现内存共享，可以处理同一片内存区域。理论上子进程能访问全部共享内存（整个数组），但是在快速排序算法中，子进程只需要负责自己的数组区间读写、排序，其他地方忽略。这样也是实现真正的共享内存，而不是因为进程之间的父子关系只共享部分内存，且共享的部分总是越来越小。

共享内存类(SharedMemory)只负责把一块内存映射进来、提供读写、以及对这块内存本身的元信息，比如数据长度、排序标志、加锁和解锁。进程管理／排序控制类才专门负责“有多少进程在干活、何时 fork、何时回收”。

## 文件结构说明

## 思考题

（1）你采用了你选择的机制而不是另外的两种机制解决该问题，请解释你做出这种选择的理由。

答：

（2）你认为另外的两种机制是否同样可以解决该问题？如果可以请给出你的思路；如果不能，请解释理由。

答：

## 实验感想
